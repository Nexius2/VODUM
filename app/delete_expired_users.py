# /app/delete_expired_users.py
import sqlite3
from datetime import datetime, timezone
from typing import Optional, List, Tuple

from logger import logger
from config import DATABASE_PATH
from tasks import update_task_status

# PlexAPI (install√© dans ton image)
from plexapi.myplex import MyPlexAccount


def get_setting_days(cur: sqlite3.Cursor) -> Optional[int]:
    """
    R√©cup√®re le d√©lai (en jours) apr√®s lequel on 'unfriend' les utilisateurs en statut 'expired'.

    Compatible avec 2 sch√©mas :
      - Table settings en key/value : key = 'delete_after_expiry_days' ou 'delete_after_days'
      - Colonne directe dans settings : colonne 'delete_after_expiry_days' ou 'delete_after_days'
    """
    # 1) Sch√©ma key/value
    for key in ("delete_after_expiry_days", "delete_after_days"):
        try:
            cur.execute("SELECT value FROM settings WHERE key=? LIMIT 1", (key,))
            row = cur.fetchone()
            if row and row[0] is not None and str(row[0]).strip() != "":
                return int(str(row[0]).strip())
        except Exception:
            pass

    # 2) Sch√©ma colonnes
    for col in ("delete_after_expiry_days", "delete_after_days"):
        try:
            cur.execute(f"SELECT {col} FROM settings LIMIT 1")
            row = cur.fetchone()
            if row and row[0] is not None and str(row[0]).strip() != "":
                return int(str(row[0]).strip())
        except Exception:
            pass

    return None



def get_admin_token(cur: sqlite3.Cursor) -> Optional[str]:
    """
    R√©cup√®re un token Plex admin utilisable.
    Priorit√©: servers.plex_token (non vide), fallback settings.plex_auth_token.
    """
    try:
        cur.execute("""
            SELECT plex_token
            FROM servers
            WHERE plex_token IS NOT NULL AND TRIM(plex_token) <> ''
            ORDER BY is_owner DESC, id ASC
            LIMIT 1
        """)
        row = cur.fetchone()
        if row and row[0]:
            return row[0]
    except Exception:
        pass

    try:
        cur.execute("SELECT value FROM settings WHERE key='plex_auth_token' LIMIT 1")
        row = cur.fetchone()
        if row and row[0]:
            return row[0]
    except Exception:
        pass

    return None


def list_expired_candidates(cur: sqlite3.Cursor, delete_after_days: int) -> List[Tuple]:
    """
    Cible les utilisateurs:
      - status = 'expired'
      - non admin, username != 'guest'
      - dont la date de bascule en 'expired' (status_changed_at, √† d√©faut expiration_date)
        est ant√©rieure √† aujourd'hui - delete_after_days.
    Retourne: (id, username, email, status_changed_at, expiration_date)
    """
    cur.execute("""
        SELECT
            id, username, email, status_changed_at, expiration_date
        FROM users
        WHERE status = 'expired'
          AND is_admin = 0
          AND LOWER(username) <> 'guest'
          AND DATE(
                COALESCE(
                    substr(status_changed_at, 1, 10),  -- 'YYYY-MM-DD' extrait si ISO
                    expiration_date
                ),
                '+' || ? || ' days'
              ) < DATE('now')
    """, (delete_after_days,))
    return cur.fetchall()


def find_friend_obj(account: MyPlexAccount, username: str, email: str):
    """
    Tente de retrouver l'ami sur Plex via username/email.
    """
    try:
        friends = account.users()  # liste des amis/partag√©s sur plex
    except Exception as e:
        logger.error(f"‚ùå Impossible de r√©cup√©rer la liste d'amis Plex: {e}")
        return None

    uname = (username or "").strip().lower()
    eml = (email or "").strip().lower()

    # Match par username ou email
    for f in friends:
        try:
            fu = (getattr(f, "username", "") or "").strip().lower()
            fe = (getattr(f, "email", "") or "").strip().lower()
            if (uname and fu == uname) or (eml and fe == eml):
                return f
        except Exception:
            continue
    return None


def unfriend_and_update_db(conn: sqlite3.Connection, account: MyPlexAccount, user_row: Tuple):
    """
    Unfriend sur Plex + mise √† jour DB locale.
    user_row = (id, username, email, status_changed_at, expiration_date)
    """
    cur = conn.cursor()
    user_id, username, email, status_changed_at, expiration_date = user_row

    # 1) Unfriend Plex
    friend_obj = find_friend_obj(account, username, email)
    try:
        if friend_obj:
            logger.info(f"üëã Unfriend Plex: {username}")
            account.removeFriend(friend_obj)
        else:
            # Fallback: certains PlexAPI acceptent removeFriend(str)
            logger.info(f"üëã Unfriend Plex (fallback str): {username}")
            account.removeFriend(username)
    except Exception as e:
        logger.error(f"‚ùå Echec unfriend Plex pour {username}: {e}")
        # On n'arr√™te pas : on continue la mise √† jour DB pour aligner l'UI
        # (update_plex_users fera l'alignement complet √† la prochaine synchro)

    # 2) Nettoyage acc√®s locaux (imm√©diat pour l‚ÄôUI)
    try:
        cur.execute("DELETE FROM user_servers WHERE user_id = ?", (user_id,))
        cur.execute("DELETE FROM user_libraries WHERE user_id = ?", (user_id,))
        cur.execute("DELETE FROM shared_libraries WHERE user_id = ?", (user_id,))
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Nettoyage acc√®s √©chou√© pour {username}: {e}")

    # 3) Statut = 'unfriended'
    cur.execute("""
        UPDATE users
        SET last_status = status,
            status = 'unfriended',
            status_changed_at = ?
        WHERE id = ?
    """, (datetime.now(timezone.utc).isoformat(), user_id))

    conn.commit()
    logger.info(f"‚úÖ {username}: statut 'unfriended' appliqu√© et acc√®s retir√©s localement")


def delete_expired_users():
    logger.info("üóëÔ∏è D√©but de la t√¢che d'unfriend des utilisateurs expir√©s")

    conn = sqlite3.connect(DATABASE_PATH, timeout=15)
    conn.row_factory = sqlite3.Row
    cur = conn.cursor()

    # 1) D√©lai de suppression / unfriend
    delete_after_days = get_setting_days(cur)
    if delete_after_days is None:
        logger.info("‚ö†Ô∏è Aucun d√©lai configur√© (keys: 'delete_after_expiry_days' ou 'delete_after_days') ‚Üí t√¢che ignor√©e")
        conn.close()
        return


    # 2) Liste des candidats
    candidates = list_expired_candidates(cur, delete_after_days)
    if not candidates:
        logger.info("‚úÖ Aucun utilisateur 'expired' √† unfriend selon la fen√™tre de temps.")
        conn.close()
        update_task_status("delete_expired_users")
        return

    # 3) Token admin Plex
    admin_token = get_admin_token(cur)
    if not admin_token:
        logger.error("üö® Aucun token admin Plex trouv√© (servers.plex_token ou settings.plex_auth_token)")
        conn.close()
        return

    # 4) Connexion Plex
    try:
        account = MyPlexAccount(token=admin_token)
    except Exception as e:
        logger.error(f"‚ùå Connexion au compte Plex admin impossible : {e}")
        conn.close()
        return

    # 5) Unfriend + update DB
    for row in candidates:
        try:
            unfriend_and_update_db(conn, account, row)
        except Exception as e:
            logger.error(f"‚ùå Erreur traitement utilisateur id={row['id']} ({row['username']}): {e}")

    conn.close()
    update_task_status("delete_expired_users")
    logger.info("üèÅ Fin de la t√¢che d'unfriend des utilisateurs expir√©s")


if __name__ == "__main__":
    delete_expired_users()
